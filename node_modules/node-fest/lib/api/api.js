#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var result_1 = require("../common/result");
var utils_1 = require("../common/utils");
var fs = require('fs');
var request = require('sync-request');
var chalk = require('chalk');
var util = require('util');
var program = require('commander');
var namedRegexp = require("named-js-regexp");
var render = require('micromustache').render;
function parseCommand() {
    var context = {};
    program
        .option('-s, --server <url>', 'server endpoints')
        .option('-f, --file <path>', 'path of the test file')
        .option('-l, --line <line_number>', 'It will execute that number only.')
        .parse(process.argv);
    // For test uncomment this line and run <node bin/cmd.js>
    //program.server = "simplestore.dipankar.co.in"
    //program.file = "/Users/dip/dipankar/node-fest/src/api/sample.txt"
    //program.line = 13;
    if (program.server) {
        //console.log("Server:"+program.server);
        context.server = program.server;
    }
    else {
        console.log("You must pass a URL: (node index.js -s google.com -f ./sample.txt )");
    }
    if (program.file) {
        //console.log("File:" + program.file);
        context.file = program.file;
    }
    else {
        console.log("You must pass a filepath: (node index.js -s google.com -f ./sample.txt )");
    }
    return context;
}
function build_test_from_line(line, i) {
    var tc = {
        line: 0, method: 'get', url: '', data: '', expected: '#', type: 'tc', context: {}
    };
    tc['line'] = i + 1;
    try {
        if (line.startsWith('sleep')) {
            tc['type'] = 'sleep';
            try {
                tc['data'] = parseInt(line.replace('sleep ', ''));
            }
            catch (err) {
                console.log(chalk.red(util.format('[ERROR/%s] INVALID SLEEP LINE: :%s', i, line)));
                throw Error("Error while reading sleep");
            }
            if (!tc['data']) {
                console.log(chalk.red(util.format('[ERROR/%s] INVALID SLEEP LINE: :%s', i, line)));
                throw Error("Error while reading sleep");
            }
            return tc;
        }
        else if (line[0] === '!') {
            tc['type'] = 'setup';
            line = line.substring(1, line.length);
        }
        else if (line[0] === '$') {
            tc['type'] = 'context';
            line = line.substring(1, line.length);
            var tokens_1 = line.split("=>");
            if (tokens_1.length != 2) {
                console.log(chalk.blue(util.format('[ERROR/%s] YOU ARE SEEING CONTEXT IN WRONG WAY: :%s', i, line)));
            }
            tc['context'] = {};
            tc['context'][tokens_1[0].trim()] = [tokens_1[1].trim()];
            return tc;
        }
        else {
            tc['type'] = 'tc';
        }
        var tokens = line.split("=>");
        tc['method'] = tokens[0].trim();
        tc['url'] = tokens[1].trim();
        if (tc['method'] === 'GET') {
            tc['expected'] = tokens[2].trim();
        }
        else if (tc['method'] === 'POST') {
            tc['data'] = tokens[2].trim();
            tc['expected'] = tokens[3].trim();
        }
        else {
            console.log(chalk.blue(util.format('[ERROR/%s] Invalid Method found :%s', i, line)));
        }
    }
    catch (e) {
        console.log(chalk.red(util.format('[ERROR/%s] Invalid testcase:%s', i, line)));
        console.log(e);
    }
    if (tc.method == "POST" && (!tc.data || !tc.expected)) {
        console.log(chalk.red(util.format('[ERROR/%s] YOU ARE MISSING POST DATA:%s', i, line)));
    }
    return tc;
}
function run_test_case(testcase) {
    return __awaiter(this, void 0, void 0, function () {
        var result, _i, testcase_1, tc, res, resStr, matched;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    result = new result_1.Result();
                    _i = 0, testcase_1 = testcase;
                    _a.label = 1;
                case 1:
                    if (!(_i < testcase_1.length)) return [3 /*break*/, 5];
                    tc = testcase_1[_i];
                    if (!(tc.type == 'sleep')) return [3 /*break*/, 3];
                    console.log(chalk.blue(util.format('[INFO/%s] Sleeping %o', tc.line, tc.data)));
                    return [4 /*yield*/, utils_1.sleep(tc.data)];
                case 2:
                    _a.sent();
                    return [3 /*break*/, 4];
                case 3:
                    // if testcase type is context.
                    if (tc.type == 'context') {
                        console.log(chalk.green(util.format('[INFO/%s] Set Context %o', tc.line, tc.context)));
                        Object.assign(context, tc.context);
                        return [3 /*break*/, 4];
                    }
                    try {
                        if (tc.data) {
                            tc.data = render(tc.data, context);
                            tc.data = JSON.parse(tc.data);
                        }
                    }
                    catch (e) {
                        console.log(e);
                        console.log(chalk.blue(util.format('[ERROR/%s] Invalid json payload:%s', tc.line, tc.data)));
                        result.markFail();
                    }
                    try {
                        tc.url = render(tc.url, context);
                        console.log(chalk.hex('#454545')(util.format("\n[TEST/%s] Executing: %s", tc.line, tc.url)));
                        res = request(tc.method, tc.url, {
                            json: tc.data
                        });
                        // We also needs to keep track status code
                        if (res.statusCode != 200) {
                            console.log(chalk.red(util.format('[ERROR/%s] Error as res.statusCode :%s', tc.line, res.statusCode)));
                            //fail_count++;
                            //continue;
                        }
                        resStr = "Unknwon resp";
                        try {
                            resStr = res.getBody('utf8');
                        }
                        catch (e) {
                            resStr = e.toString();
                        }
                        try {
                            matched = new namedRegexp(tc['expected']).exec(resStr);
                        }
                        catch (e) {
                            console.log(chalk.red(util.format("[INFO/%s] Invalid Reg Exp(marked failed): \n Invalid here: %s \n Trying to match: %s", tc.line, tc['expected'], resStr)));
                            result.markFail();
                            return [3 /*break*/, 4];
                        }
                        if (matched == null) {
                            console.log(chalk.red(util.format('[ERROR/%s] Output and Expected different:\nUrl:%s\nExpected: %s\nOutput:%s', tc.line, tc.url, tc['expected'], resStr)));
                            result.markFail();
                            return [3 /*break*/, 4];
                        }
                        if (tc.type === 'tc') {
                            console.log(chalk.green(util.format('[INFO/%s] Test passed', tc.line)));
                            result.markPass();
                        }
                        else {
                            console.log(chalk.blue(util.format('[INFO/%s] Setup request Success', tc.line)));
                        }
                        // Try Capture Context which will be used lateron.
                        if (matched.groups() != null && Object.keys(matched.groups()).length > 0) {
                            Object.assign(context, matched.groups());
                            console.log(chalk.blue(util.format("[INFO/%s] Updated context: %o", tc.line, matched.groups())));
                            console.log(chalk.blue(util.format("[INFO/%s] New context: %o", tc.line, context)));
                        }
                    }
                    catch (e) {
                        result.markFail();
                        console.log(chalk.blue(util.format('[ERROR/%s] Test INFRA Exception: %s', tc.line, e)));
                    }
                    _a.label = 4;
                case 4:
                    _i++;
                    return [3 /*break*/, 1];
                case 5:
                    result.printResult();
                    return [2 /*return*/];
            }
        });
    });
}
// Main function
console.log('Starting API Test...');
var context = parseCommand();
var contents = fs.readFileSync(context.file, 'utf8');
var lines = contents.split("\n");
var lineIdx = 0;
if (program.line) {
    console.log("Executing from Line: :" + program.line);
    lineIdx = parseInt(program.line) - 1;
}
console.log(chalk.yellow(util.format("[INFO] Reading Test case %s", lines.length)));
var testcase = [];
for (; lineIdx < lines.length; lineIdx++) {
    var line = lines[lineIdx];
    if (line.trim().length == 0) {
        continue;
    }
    if (line[0] === '#') {
        continue;
    }
    testcase.push(build_test_from_line(line, lineIdx));
}
console.log(chalk.yellow(util.format("[INFO] Runnung test case now: %s", testcase.length)));
(function () { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, run_test_case(testcase)];
            case 1:
                _a.sent();
                return [2 /*return*/];
        }
    });
}); })();
//# sourceMappingURL=api.js.map